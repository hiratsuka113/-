<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Radial Delay (center -> edge)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    .ui{
      position:fixed; top:10px; left:10px;
      color:#fff; font-family: ui-monospace, Menlo, monospace;
      background: rgba(0,0,0,0.35);
      padding:10px 12px; border:1px solid rgba(255,255,255,0.25);
      border-radius: 12px; line-height:1.35; user-select:none;
    }
    label{ display:block; font-size:12px; opacity:0.9; margin-top:8px; }
    input[type="range"]{ width:280px; }
    .small{ font-size:12px; opacity:0.75; margin-top:6px; }
  </style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="ui">
    <div>中心遅延: <b><span id="cval">0</span></b> ms</div>
    <div>外側遅延: <b><span id="eval">900</span></b> ms</div>
    <div>リング数: <b><span id="rval">8</span></b></div>

    <label>中心遅延 (ms)
      <input id="centerDelay" type="range" min="0" max="1000" value="0">
    </label>
    <label>外側遅延 (ms)
      <input id="edgeDelay" type="range" min="0" max="3000" value="900">
    </label>
    <label>リング数（増やすほど重い）
      <input id="rings" type="range" min="2" max="20" value="8">
    </label>

    <div class="small">
      ※ まず「中心0 / 外側800〜1500 / リング6〜10」くらいで試すのがおすすめ
    </div>
  </div>

<script>
(async () => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });

  // UI
  const centerDelayEl = document.getElementById('centerDelay');
  const edgeDelayEl   = document.getElementById('edgeDelay');
  const ringsEl       = document.getElementById('rings');
  const cval = document.getElementById('cval');
  const evalEl = document.getElementById('eval');
  const rval = document.getElementById('rval');

  function syncUI(){
    cval.textContent = centerDelayEl.value;
    evalEl.textContent = edgeDelayEl.value;
    rval.textContent = ringsEl.value;
  }
  centerDelayEl.addEventListener('input', syncUI);
  edgeDelayEl.addEventListener('input', syncUI);
  ringsEl.addEventListener('input', syncUI);
  syncUI();

  // Canvas解像度
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    cv.width  = Math.floor(innerWidth * dpr);
    cv.height = Math.floor(innerHeight * dpr);
    // オフスクリーンも追従
    maskCanvas.width = cv.width;
    maskCanvas.height = cv.height;
  }
  addEventListener('resize', resize);

  // 背面カメラ
  const video = document.createElement('video');
  video.playsInline = true;
  video.muted = true;
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: "environment" },
    audio: false
  });
  video.srcObject = stream;
  await video.play();

  // フレームキュー（遅延表示用）
  const queue = []; // { t, img: ImageBitmap }
  const maxHoldMs = 7000; // 外側遅延を大きくする場合に備えて長め

  async function captureFrame(){
    // 取りすぎると重いので、必要なら「数フレームに1回」にしてもOK
    const bmp = await createImageBitmap(video);
    queue.push({ t: performance.now(), img: bmp });

    const now = performance.now();
    while (queue.length && (now - queue[0].t) > maxHoldMs) {
      queue[0].img.close?.();
      queue.shift();
    }
  }

  // targetTime（now-delay）に最も近いフレームを返す
  // 末尾から探すと速い（最近の方が使われやすい）
  function getFrameAtTime(targetTime){
    if (!queue.length) return null;
    for (let i = queue.length - 1; i >= 0; i--) {
      if (queue[i].t <= targetTime) return queue[i].img;
    }
    // それでも見つからなければ最古
    return queue[0].img;
  }

  // リング用マスクを作って合成するためのオフスクリーン
  const maskCanvas = document.createElement('canvas');
  const mctx = maskCanvas.getContext('2d');

  resize();

  function drawRingMask(cx, cy, rInner, rOuter){
    const w = cv.width, h = cv.height;
    mctx.clearRect(0,0,w,h);
    mctx.fillStyle = "#fff";
    // 外円
    mctx.beginPath();
    mctx.arc(cx, cy, rOuter, 0, Math.PI * 2);
    mctx.closePath();
    mctx.fill();
    // 内円をくり抜く
    mctx.globalCompositeOperation = "destination-out";
    mctx.beginPath();
    mctx.arc(cx, cy, rInner, 0, Math.PI * 2);
    mctx.closePath();
    mctx.fill();
    mctx.globalCompositeOperation = "source-over";
  }

  function drawMaskedFrame(frame, mask){
    // いま描いたものにマスク適用するのではなく、
    // “フレームを描いた後に destination-in でマスク”の方が楽。
    const w = cv.width, h = cv.height;

    // 一旦フレームを描く（全画面）
    ctx.drawImage(frame, 0, 0, w, h);

    // マスクで切り抜き（リング部分だけ残す）
    ctx.globalCompositeOperation = "destination-in";
    ctx.drawImage(mask, 0, 0, w, h);

    // 次の合成に備えて戻す
    ctx.globalCompositeOperation = "source-over";
  }

  async function loop(){
    await captureFrame();

    const now = performance.now();
    const w = cv.width, h = cv.height;
    const cx = w / 2, cy = h / 2;

    let centerDelay = Number(centerDelayEl.value);
    let edgeDelay = Number(edgeDelayEl.value);
    if (centerDelay > edgeDelay) [centerDelay, edgeDelay] = [edgeDelay, centerDelay];

    const rings = Number(ringsEl.value);

    // 画面の最大半径（角まで届く）
    const maxR = Math.hypot(cx, cy);

    // ベースを黒でクリア
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,w,h);

    // 内側→外側へリングを重ね描き
    for (let i = 0; i < rings; i++) {
      const t0 = i / rings;
      const t1 = (i + 1) / rings;

      const rInner = maxR * t0;
      const rOuter = maxR * t1;

      // 外側ほど遅延が大きい
      const delayMs = centerDelay + (edgeDelay - centerDelay) * t1;
      const targetTime = now - delayMs;

      const frame = getFrameAtTime(targetTime);
      if (!frame) continue;

      // リングマスク生成 → そのリングだけフレームを表示
      drawRingMask(cx, cy, rInner, rOuter);

      // そのリング部分を描く（上に重ねる）
      ctx.save();
      drawMaskedFrame(frame, maskCanvas);
      ctx.restore();
    }

    requestAnimationFrame(() => loop().catch(console.error));
  }

  loop().catch(console.error);
})();
</script>
</body>
</html>



