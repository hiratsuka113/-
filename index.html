<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Radial Delay (Curved Increase)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    .ui{
      position:fixed; top:10px; left:10px;
      color:#fff; font-family: ui-monospace, Menlo, monospace;
      background: rgba(0,0,0,0.35);
      padding:10px 12px; border:1px solid rgba(255,255,255,0.25);
      border-radius: 12px; line-height:1.35; user-select:none;
    }
    label{ display:block; font-size:12px; opacity:0.9; margin-top:8px; }
    input[type="range"]{ width:300px; }
    .small{ font-size:12px; opacity:0.75; margin-top:6px; max-width: 340px; }
  </style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="ui">
    <div>中心遅延: <b><span id="cval">0</span></b> ms（ほぼ0固定）</div>
    <div>外側遅延: <b><span id="eval">1200</span></b> ms</div>
    <div>リング数: <b><span id="rval">10</span></b></div>
    <div>カーブ強さ: <b><span id="pval">2.2</span></b></div>

    <label>外側遅延 (ms)
      <input id="edgeDelay" type="range" min="0" max="3000" value="1200">
    </label>

    <label>リング数（増やすほど重い）
      <input id="rings" type="range" min="2" max="24" value="10">
    </label>

    <label>カーブ強さ（外側で急増） 1.0=直線
      <input id="power" type="range" min="10" max="60" value="22">
      <!-- 10..60 を 1.0..6.0 にマッピング -->
    </label>

    <div class="small">
      おすすめ：外側800〜1500ms、リング8〜14、カーブ2〜4。<br>
      ※外側2000ms超えは酔いやすいので注意。
    </div>
  </div>

<script>
(async () => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });

  // UI
  const edgeDelayEl = document.getElementById('edgeDelay');
  const ringsEl = document.getElementById('rings');
  const powerEl = document.getElementById('power');

  const cval = document.getElementById('cval');
  const evalEl = document.getElementById('eval');
  const rval = document.getElementById('rval');
  const pval = document.getElementById('pval');

  // 中心遅延は「ほぼ0」に固定（必要なら 0〜50ms くらいにしてもOK）
  const centerDelayMs = 0;
  cval.textContent = String(centerDelayMs);

  function powerValue(){
    return Number(powerEl.value) / 10; // 1.0..6.0
  }
  function syncUI(){
    evalEl.textContent = edgeDelayEl.value;
    rval.textContent = ringsEl.value;
    pval.textContent = powerValue().toFixed(1);
  }
  edgeDelayEl.addEventListener('input', syncUI);
  ringsEl.addEventListener('input', syncUI);
  powerEl.addEventListener('input', syncUI);
  syncUI();

  // Canvas解像度
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    cv.width  = Math.floor(innerWidth * dpr);
    cv.height = Math.floor(innerHeight * dpr);
    maskCanvas.width = cv.width;
    maskCanvas.height = cv.height;
  }
  addEventListener('resize', resize);

  // 背面カメラ
  const video = document.createElement('video');
  video.playsInline = true;
  video.muted = true;
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: "environment" },
    audio: false
  });
  video.srcObject = stream;
  await video.play();

  // フレームキュー（遅延用）
  const queue = []; // { t, img: ImageBitmap }
  const maxHoldMs = 8000; // 外側遅延が大きいのに備えて長め

  async function captureFrame(){
    const bmp = await createImageBitmap(video);
    queue.push({ t: performance.now(), img: bmp });

    const now = performance.now();
    while (queue.length && (now - queue[0].t) > maxHoldMs) {
      queue[0].img.close?.();
      queue.shift();
    }
  }

  function getFrameAtTime(targetTime){
    if (!queue.length) return null;
    for (let i = queue.length - 1; i >= 0; i--) {
      if (queue[i].t <= targetTime) return queue[i].img;
    }
    return queue[0].img; // 最古
  }

  // リングマスク用オフスクリーン
  const maskCanvas = document.createElement('canvas');
  const mctx = maskCanvas.getContext('2d');

  resize();

  function drawRingMask(cx, cy, rInner, rOuter){
    const w = cv.width, h = cv.height;
    mctx.clearRect(0,0,w,h);

    // 外円
    mctx.fillStyle = "#fff";
    mctx.beginPath();
    mctx.arc(cx, cy, rOuter, 0, Math.PI * 2);
    mctx.closePath();
    mctx.fill();

    // 内円をくり抜く
    mctx.globalCompositeOperation = "destination-out";
    mctx.beginPath();
    mctx.arc(cx, cy, rInner, 0, Math.PI * 2);
    mctx.closePath();
    mctx.fill();
    mctx.globalCompositeOperation = "source-over";
  }

  function drawMaskedFrame(frame){
    const w = cv.width, h = cv.height;
    // フレームを全画面に描く
    ctx.drawImage(frame, 0, 0, w, h);
    // リングマスクで切り抜く
    ctx.globalCompositeOperation = "destination-in";
    ctx.drawImage(maskCanvas, 0, 0, w, h);
    ctx.globalCompositeOperation = "source-over";
  }

  // 0..1 を曲線に（外側ほど急増）: u^p
  function curved(u, p){
    u = Math.max(0, Math.min(1, u));
    return Math.pow(u, p);
  }

  async function loop(){
    await captureFrame();

    const now = performance.now();
    const w = cv.width, h = cv.height;
    const cx = w / 2, cy = h / 2;

    const edgeDelayMs = Number(edgeDelayEl.value);
    const rings = Number(ringsEl.value);
    const p = powerValue();

    const maxR = Math.hypot(cx, cy);

    // クリア
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,w,h);

    // 内→外へ描画
    for (let i = 0; i < rings; i++) {
      const u0 = i / rings;
      const u1 = (i + 1) / rings;

      const rInner = maxR * u0;
      const rOuter = maxR * u1;

      // 遅延は「リングの外側位置 u1」を使って決める
      const k = curved(u1, p); // 0..1（外ほど増える）
      const delayMs = centerDelayMs + (edgeDelayMs - centerDelayMs) * k;

      const frame = getFrameAtTime(now - delayMs);
      if (!frame) continue;

      drawRingMask(cx, cy, rInner, rOuter);
      drawMaskedFrame(frame);
    }

    requestAnimationFrame(() => loop().catch(console.error));
  }

  loop().catch(console.error);
})();
</script>
</body>
</html>




