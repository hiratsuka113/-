<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Delayed Camera (Delay-linked RGB Shift)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    .ui {
      position:fixed; top:10px; left:10px;
      color:#fff; font-family: ui-monospace, Menlo, monospace;
      background: rgba(0,0,0,0.35); padding:10px 12px;
      border:1px solid rgba(255,255,255,0.25); border-radius: 12px;
      line-height: 1.35;
      user-select: none;
    }
    .row { margin-top: 8px; }
    label { display:block; font-size: 12px; opacity: 0.9; margin-bottom: 4px; }
    input[type="range"] { width: 280px; }
    .pill {
      display:inline-block; padding:4px 8px; border:1px solid rgba(255,255,255,0.25);
      border-radius: 999px; font-size: 12px; opacity:0.9;
    }
    button {
      margin-top: 8px;
      padding:6px 10px;
      border:1px solid rgba(255,255,255,0.25);
      border-radius:10px;
      background: rgba(255,255,255,0.06);
      color:#fff;
      font-family: inherit;
    }
  </style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="ui">
    <div class="pill">LIVE</div>
    <div>Delay: <b><span id="msNow">---</span></b> ms / RGB Shift: <b><span id="rgbNow">---</span></b> px</div>

    <div class="row">
      <label>遅延の下限 (min ms): <span id="minLabel">150</span></label>
      <input id="minDelay" type="range" min="0" max="2000" value="150" />
    </div>

    <div class="row">
      <label>遅延の上限 (max ms): <span id="maxLabel">1200</span></label>
      <input id="maxDelay" type="range" min="0" max="3000" value="1200" />
    </div>

    <div class="row">
      <label>ゆらぎの速さ (Hz): <span id="speedLabel">0.25</span></label>
      <input id="speed" type="range" min="1" max="300" value="25" />
    </div>

    <div class="row">
      <label>色ズレの最大量 (px): <span id="rgbMaxLabel">24</span></label>
      <input id="rgbMax" type="range" min="0" max="80" value="24" />
    </div>

    <button id="toggle">ゆらぎ: ON（タップで切替）</button>
    <div style="opacity:0.7; font-size:12px; margin-top:6px;">
      ※遅延maxを大きくすると酔いやすい。まず max 800〜1500ms 推奨
    </div>
  </div>

<script>
(async () => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });

  const msNow = document.getElementById('msNow');
  const rgbNow = document.getElementById('rgbNow');

  const minDelayEl = document.getElementById('minDelay');
  const maxDelayEl = document.getElementById('maxDelay');
  const speedEl = document.getElementById('speed');
  const rgbMaxEl = document.getElementById('rgbMax');

  const minLabel = document.getElementById('minLabel');
  const maxLabel = document.getElementById('maxLabel');
  const speedLabel = document.getElementById('speedLabel');
  const rgbMaxLabel = document.getElementById('rgbMaxLabel');

  const toggleBtn = document.getElementById('toggle');
  let wobbleOn = true;

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    cv.width = Math.floor(innerWidth * dpr);
    cv.height = Math.floor(innerHeight * dpr);
  }
  addEventListener('resize', resize);
  resize();

  // ---- カメラ（背面） ----
  const video = document.createElement('video');
  video.playsInline = true;
  video.muted = true;

  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: "environment" },
    audio: false
  });
  video.srcObject = stream;
  await video.play();

  // ---- UI反映 ----
  function refreshLabels(){
    let minMs = Number(minDelayEl.value);
    let maxMs = Number(maxDelayEl.value);
    if (minMs > maxMs) [minMs, maxMs] = [maxMs, minMs];
    minLabel.textContent = String(minMs);
    maxLabel.textContent = String(maxMs);

    const hz = Number(speedEl.value) / 100; // 0.01..3.00
    speedLabel.textContent = hz.toFixed(2);

    rgbMaxLabel.textContent = String(Number(rgbMaxEl.value));
  }
  minDelayEl.addEventListener('input', refreshLabels);
  maxDelayEl.addEventListener('input', refreshLabels);
  speedEl.addEventListener('input', refreshLabels);
  rgbMaxEl.addEventListener('input', refreshLabels);
  refreshLabels();

  toggleBtn.addEventListener('click', () => {
    wobbleOn = !wobbleOn;
    toggleBtn.textContent = `ゆらぎ: ${wobbleOn ? "ON" : "OFF（固定）"}（タップで切替）`;
  });

  // ---- スムーズランダム（曲線っぽい） ----
  let n0 = Math.random();
  let n1 = Math.random();
  let lastStepT = performance.now();
  let stepInterval = 1000;

  function smoothstep(t){
    return t * t * (3 - 2 * t);
  }

  function getWobble01(now){
    const hz = Number(speedEl.value) / 100; // 0.01..3.00
    stepInterval = 1 / Math.max(0.01, hz) * 1000;

    while ((now - lastStepT) > stepInterval) {
      lastStepT += stepInterval;
      n0 = n1;
      n1 = Math.random();
    }

    const t = Math.min(1, Math.max(0, (now - lastStepT) / stepInterval));
    return n0 + (n1 - n0) * smoothstep(t);
  }

  // ---- フレームキュー ----
  const queue = []; // {t, img: ImageBitmap}
  const maxHoldMs = 6000;

  async function captureFrame(){
    const bmp = await createImageBitmap(video);
    queue.push({ t: performance.now(), img: bmp });

    const now = performance.now();
    while (queue.length && (now - queue[0].t) > maxHoldMs) {
      queue[0].img.close?.();
      queue.shift();
    }
  }

  // delayの現在値を計算
  function currentDelayMs(now){
    let minMs = Number(minDelayEl.value);
    let maxMs = Number(maxDelayEl.value);
    if (minMs > maxMs) [minMs, maxMs] = [maxMs, minMs];

    if (!wobbleOn) return Math.round((minMs + maxMs) / 2);

    const r = getWobble01(now);
    return Math.round(minMs + (maxMs - minMs) * r);
  }

  // 遅延に応じた「バグ度」0..1
  function bugAmount(delayMs){
    let minMs = Number(minDelayEl.value);
    let maxMs = Number(maxDelayEl.value);
    if (minMs > maxMs) [minMs, maxMs] = [maxMs, minMs];
    const denom = Math.max(1, (maxMs - minMs));
    let a = (delayMs - minMs) / denom;
    a = Math.max(0, Math.min(1, a));
    // ちょい曲線にして「後半で急に増える」感じに
    return a * a; // 0..1
  }

  function drawWithRgbShift(img, shiftPx){
    const w = cv.width, h = cv.height;

    // ベース
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1.0;
    ctx.drawImage(img, 0, 0, w, h);

    if (shiftPx <= 0.1) return;

    // RGBっぽく見えるように「ずらして加算」
    // 色分離を厳密にやるより、軽くてそれっぽい方法
    ctx.globalCompositeOperation = 'screen';

    // 赤寄り（右に）
    ctx.globalAlpha = 0.22;
    ctx.drawImage(img, +shiftPx, 0, w, h);

    // 青寄り（左に）
    ctx.globalAlpha = 0.18;
    ctx.drawImage(img, -shiftPx, 0, w, h);

    // 仕上げ
    ctx.globalAlpha = 1.0;
    ctx.globalCompositeOperation = 'source-over';
  }

  async function loop(){
    await captureFrame();

    const now = performance.now();
    const delayMs = currentDelayMs(now);
    msNow.textContent = String(delayMs);

    // 遅延→バグ度→色ズレ量
    const a = bugAmount(delayMs); // 0..1
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rgbMax = Number(rgbMaxEl.value) * dpr;
    const shiftPx = rgbMax * a;

    rgbNow.textContent = (shiftPx / dpr).toFixed(1);

    // 遅延分のフレームを選ぶ
    const targetTime = now - delayMs;
    while (queue.length >= 2 && queue[1].t <= targetTime) {
      queue[0].img.close?.();
      queue.shift();
    }

    const frame = queue[0]?.img;
    if (frame) drawWithRgbShift(frame, shiftPx);

    requestAnimationFrame(() => loop().catch(console.error));
  }

  loop().catch(console.error);
})();
</script>
</body>
</html>



